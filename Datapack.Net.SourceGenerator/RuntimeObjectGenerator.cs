using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGeneratorsKit;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Datapack.Net.SourceGenerator
{
	[Generator]
	public class RuntimeObjectGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var projects = context.SyntaxProvider.ForAttributeWithMetadataName<RuntimeObject?>("Datapack.Net.CubeLib.RuntimeObjectAttribute",
				static (s, _) => true,
				static (ctx, _) =>
				{
					//if (!Debugger.IsAttached)
					//{
					//    Debugger.Launch();
					//}

					var cls = (ClassDeclarationSyntax)ctx.TargetNode;

					foreach (var i in cls.AttributeLists)
					{
						foreach (var e in i.Attributes)
						{
							if (ctx.SemanticModel.GetSymbolInfo(e).Symbol is not IMethodSymbol attribute)
							{
								continue;
							}

							if (attribute.ContainingType.ToDisplayString() == "Datapack.Net.CubeLib.RuntimeObjectAttribute")
							{
								if (ctx.SemanticModel.GetDeclaredSymbol(cls) is not INamedTypeSymbol clsSymbol)
								{
									return null;
								}

								List<MCFunction> funcs = [];
								List<RuntimeObjectProperty> props = [];

								foreach (var sym in clsSymbol.GetMembers())
								{
									if (sym is IMethodSymbol method && method.GetAttributes().Where(i => i.AttributeClass.ToDisplayString().Contains("Datapack.Net.CubeLib.DeclareMC")).Count() != 0 && sym.IsStatic)
									{
										funcs.Add(Utils.GetMCFunction(method));
									}

									else if (sym is INamedTypeSymbol propCls && propCls.Name.Contains("Props"))
									{
										foreach (var propSym in propCls.GetMembers())
										{
											if (propSym is IPropertySymbol prop && prop.HasAttribute("Datapack.Net.CubeLib.RuntimePropertyAttribute"))
											{
												var internalName = prop.FindAttribute("Datapack.Net.CubeLib.RuntimePropertyAttribute").ConstructorArguments.FirstOrDefault().Value.ToString();
												props.Add(new(prop.Name, internalName, prop.Type.ToDisplayString(), prop.Type.AllInterfaces.Where(i => i.ToDisplayString().Contains("Datapack.Net.CubeLib.IRuntimeProperty")).Count() != 0));
											}
										}
									}
								}

								var name = new StringBuilder(clsSymbol.Name);
								if (clsSymbol.TypeParameters.Length > 0)
								{
									_ = name.Append("<");
									foreach (var t in clsSymbol.TypeParameters)
									{
										_ = name.Append($"{t.Name}, ");
									}

									name.Length -= 2;
									_ = name.Append(">");
								}

								return new RuntimeObject(name.ToString(), clsSymbol.ContainingNamespace.ToDisplayString(), !(e.ArgumentList.Arguments.Count == 2 && e.ArgumentList.Arguments[1].Expression.ToString() == "false"), funcs, props);
							}
						}
					}

					return null;
				}
			).Where(static m => m is not null);

			context.RegisterSourceOutput(projects, static (spc, source) => Execute(source, spc));
		}

		private static void Execute(RuntimeObject? _obj, SourceProductionContext context)
		{
			if (_obj is not { } obj)
			{
				return;
			}

			var things = new StringBuilder();

			foreach (var i in obj.Properties)
			{
				var type = i.IsObj ? i.Type : Utils.ProcessRuntimePropertyType(i.Type);
				var postfix = i.IsObj ? "Obj" : "Prop";

				_ = things.AppendLine($"        /// <inheritdoc cref=\"{obj.Namespace}.{obj.Name}.Props.{i.Name}\"/>");
				_ = things.AppendLine($"        public {type} {i.Name} {{ get => new(this.Get{postfix}<{i.Type}>(\"{i.InternalName}\"){(i.IsObj ? ".Pointer" : "")}); set => this.SetProp(\"{i.InternalName}\", value); }}");
			}

			foreach (var i in obj.Methods)
			{
				_ = things.AppendLine(Utils.GenerateWrapper(i, true));
			}

			if (things.Length > 0)
			{
				_ = things.Append("\n");
			}

			_ = things.Append("        public override (string, Type)[] AllProperties => [");

			if (obj.Properties.Length > 0)
			{
				foreach (var i in obj.Properties)
				{
					_ = things.Append($"(\"{i.InternalName}\", typeof({i.Type})), ");
				}

				things.Length -= 2;
			}

			_ = things.Append("];");

			if (obj.ImplementCleanup)
			{
				_ = things.Append($"\n\n        [global::Datapack.Net.CubeLib.DeclareMC(\"deinit\")]\n        private static void _FreePointers({obj.Name} self)\n        {{\n");

				if (obj.Properties.Length > 0)
				{
					foreach (var i in obj.Properties)
					{
						if (i.IsObj)
						{
							_ = things.Append($"            global::Datapack.Net.CubeLib.Project.ActiveProject.If(self.{i.Name}.Pointer.Exists(), ((global::Datapack.Net.CubeLib.Builtins.RuntimePointer<{i.Type}>)self.{i.Name}.Pointer).RemoveOneReference);\n");
						}
					}
				}

				_ = things.Append("        }");
			}

			var source = $@"/// <auto-generated/>
namespace {obj.Namespace}
{{
    public partial class {obj.Name}
    {{
{things}
    }}
}}";
			context.AddSource($"{obj.Name.Split('<')[0]}.g.cs", source);
		}
	}
}
