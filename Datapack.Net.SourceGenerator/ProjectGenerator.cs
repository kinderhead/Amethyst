using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGeneratorsKit;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Datapack.Net.SourceGenerator
{
    [Generator]
    public class ProjectGenerator : ISourceGenerator
    {
        public static readonly DiagnosticDescriptor InvalidFunctionFormat = new("MC0001", "Invalid Function", "Function {0} is not a valid Datapack function, and it must be private and its name must start with an underscore", "Datapack", DiagnosticSeverity.Error, true);

        private readonly SyntaxReceiver Projects = new DerivedClassesReceiver("Project");

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is SyntaxReceiver)) return;

            foreach (var i in Projects.Classes)
            {
                ProcessClass(context, i);
            }
        }

        public void ProcessClass(GeneratorExecutionContext context, INamedTypeSymbol symbol)
        {
            if (symbol.Name == "Project") return;

            var funcs = new StringBuilder();

            foreach (var i in symbol.GetMembers())
            {
                if (i.Kind == SymbolKind.Method && i.GetAttributes().Where((x) => x.AttributeClass.Name == "DeclareMCAttribute").Count() != 0)
                {
                    if (!i.Name.StartsWith("_"))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(InvalidFunctionFormat, i.Locations.FirstOrDefault(), i.ToDisplayString()));
                        continue;
                    }

                    var method = (IMethodSymbol)i;

                    funcs.Append($"\t\t///<inheritdoc cref=\"{method.GetDocumentationCommentId()}\"/>\n");
                    funcs.Append($"\t\tpublic void {method.Name.ToString().Substring(1)}(");

                    foreach (var arg in method.Parameters)
                    {
                        funcs.Append($"{arg.Type.Name} {arg.Name}, ");
                    }

                    if (method.Parameters.Length > 0) funcs.Length -= 2;
                    funcs.Append(") => ");

                    if (method.Parameters.Length > 0)
                    {
                        funcs.Append($"CallArg({method.Name}, ");
                        foreach (var arg in method.Parameters)
                        {
                            funcs.Append($"{arg.Name}, ");
                        }
                        funcs.Length -= 2;
                    }
                    else
                    {
                        funcs.Append($"Call({method.Name}");
                    }

                    funcs.Append(");\n");
                }
            }

            if (funcs.Length > 0) funcs.Length--;

            string source = $@"using Datapack.Net.CubeLib;

// <auto-generated/>
namespace {symbol.ContainingNamespace.ToDisplayString()}
{{
    public partial class {symbol.Name}
    {{
{funcs}
    }}
}}";
            context.AddSource($"{symbol.Name}.g.cs", source);
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => Projects);
        }
    }
}
